using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.Extensions.Options;

namespace ChitterChatterDistribution.Pages;

[Authorize(Policy = "NginxOrJwt")]
public class IndexModel : PageModel
{
    private readonly DistributionOptions _options;
    private readonly ILogger<IndexModel>
    _logger;

    public string Version { get; private set; } = "1.0.0";
    public string FileName { get; private set; } = "";
    public string FileSize { get; private set; } = "";
    public bool IsAvailable { get; private set; }

    public IndexModel(IOptions<DistributionOptions>
        options, ILogger<IndexModel>
            logger)
            {
            _options = options.Value;
            _logger = logger;
            }

            public void OnGet()
            {
            var userInfo = GetUserInfo();

            _logger.LogInformation(
            "Download page visited - User: {User}, Email: {Email}, IP: {IP}, UserAgent: {UserAgent}, AuthMethod: {AuthMethod}",
            userInfo.Name, userInfo.Email, userInfo.IP, userInfo.UserAgent, userInfo.AuthMethod);

            var distPath = _options.DistributionPath;

            // Look for the installer zip
            var zipPath = Path.Combine(distPath, "ChitterChatter-Setup.zip");

            if (System.IO.File.Exists(zipPath))
            {
            IsAvailable = true;
            FileName = "ChitterChatter-Setup.zip";

            var fileInfo = new FileInfo(zipPath);
            FileSize = FormatFileSize(fileInfo.Length);

            // Try to read version from a version.txt file if present
            var versionPath = Path.Combine(distPath, "version.txt");
            if (System.IO.File.Exists(versionPath))
            {
            Version = System.IO.File.ReadAllText(versionPath).Trim();
            }

            _logger.LogDebug(
            "Distribution available - Version: {Version}, Size: {Size}",
            Version, FileSize);
            }
            else
            {
            IsAvailable = false;
            _logger.LogWarning(
            "Distribution file not found: {Path} - User: {User} will see unavailable message",
            zipPath, userInfo.Name);
            }
            }

            private (string Name, string Email, string IP, string UserAgent, string AuthMethod) GetUserInfo()
            {
            var name = User.Identity?.Name ?? "anonymous";
            var email = User.Claims.FirstOrDefault(c => c.Type == "email")?.Value ?? "unknown";
            var ip = HttpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
            var userAgent = Request.Headers.UserAgent.ToString();

            // Determine auth method
            var authMethod = User.Identity?.IsAuthenticated == true ? "JWT" : "Nginx-Proxy";
            if (Request.Headers.TryGetValue("X-Nginx-Proxy", out var nginxHeader) && nginxHeader == "authenticated")
            {
            authMethod = User.Identity?.IsAuthenticated == true ? "JWT+Nginx" : "Nginx-Proxy";
            }

            // Get real IP if behind proxy
            if (Request.Headers.TryGetValue("X-Forwarded-For", out var forwardedFor))
            {
            ip = forwardedFor.ToString().Split(',').First().Trim();
            }
            else if (Request.Headers.TryGetValue("X-Real-IP", out var realIp))
            {
            ip = realIp.ToString();
            }

            return (name, email, ip, userAgent, authMethod);
            }

            private static string FormatFileSize(long bytes)
            {
            string[] sizes = ["B", "KB", "MB", "GB"];
            int order = 0;
            double size = bytes;

            while (size >= 1024 && order < sizes.Length - 1)
            {
            order++;
            size /= 1024;
            }

            return $"{size:0.##} {sizes[order]}";
            }
            }
